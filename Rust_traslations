use std::ptr;
use std::mem;
use std::fs::File;
use std::io::{self, Read};
use std::os::unix::io::AsRawFd;

//Initializations

static mut P: *mut u8 = ptr::null_mut();     
static mut LP: *mut u8 = ptr::null_mut();    
static mut DATA: *mut u8 = ptr::null_mut(); 

static mut E: *mut i64 = ptr::null_mut();   
static mut LE: *mut i64 = ptr::null_mut();   
static mut ID: *mut i64 = ptr::null_mut();   
static mut SYM: *mut i64 = ptr::null_mut();  

static mut TK: i64 = 0;      
static mut IVAL: i64 = 0;    
static mut TY: i64 = 0;     
static mut LOC: i64 = 0;    
static mut LINE: i64 = 0;    
static mut SRC: i64 = 0;    
static mut DEBUG: i64 = 0;  

// tokens and classes (operators last and in precedence order)
#[repr(i64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Token {
    Num = 128, Fun, Sys, Glo, Loc, Id,
    Char, Else, Enum, If, Int, Return, Sizeof, While,
    Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr,
    Add, Sub, Mul, Div, Mod, Inc, Dec, Brak,
}

// opcodes
#[repr(i64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Opcode {
    LEA, IMM, JMP, JSR, BZ, BNZ, ENT, ADJ, LEV, LI, LC, SI, SC, PSH,
    OR, XOR, AND, EQ, NE, LT, GT, LE, GE, SHL, SHR, ADD, SUB, MUL, DIV, MOD,
    OPEN, READ, CLOS, PRTF, MALC, FREE, MSET, MCMP, EXIT,
}

// types
#[repr(i64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TypeKind {
    CHAR,
    INT,
    PTR,
}

// identifier offsets (since we can't create an ident struct)
#[repr(i64)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum IdentField {
    Tk,
    Hash,
    Name,
    Class,
    Type,
    Val,
    HClass,
    HType,
    HVal,
    Idsz,
}


